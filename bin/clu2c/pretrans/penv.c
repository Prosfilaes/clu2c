/* Generated by clu2c (version 1.99.3) */
/* option, optimize time */
/* depend,p_env,ce,cprint_form,du,expr,int_hex_parse,int_oct_parse,pt_token,stream,tokentab,typespec*/
/* depend,cprint_form*/
/* depend,jkindlist,init_klist,table*/
/* param_mod_call,clop,PV1_INjkindlist_Dnew,jkindlist$new,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],create,no_param*/
/* param_mod_call,clop,PV2_INjkindlist_Dnew,jkindlist$new,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],bind,no_param*/
/* param_mod_call,clop,PV3_INjkindlist_Dnew,jkindlist$new,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],mbind,no_param*/
/* param_mod_call,clop,PV4_INjkindlist_Dnew,jkindlist$new,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],delete,no_param*/
/* param_mod_call,clop,PV5_INjkindlist_Dnew,jkindlist$new,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],bind,no_param*/
/* param_mod_call,clop,PV1_INjkindlist_Dfetch,jkindlist$fetch,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],lookup,no_param*/
/* param_mod_call,clop,PV2_INjkindlist_Dfetch,jkindlist$fetch,table[int oneof[blank:bool comment:null digit:char eol:null escape:null funny:oneof[at:null hat:null other:null question:null] illegal:null letter:char mtoken:oneof[asterisk:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] colon:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] gt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] lt:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] period:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] slash:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] tilde:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null] vbar:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]] quote1:null quote2:null token:oneof[assn:null colon:null comma:null defnkey:oneof[applytype_:null cluster_:null iter_:du proc_:du selector_:null] do_:null dollar:null else_:null elseif_:null end_:null eof:null equal:struct[neg:bool op:string prec:int] except_:null exclm:null expr:oneof[a_cons:record[elts:sequence[expr] low:oneof[none:null one:expr] type_:typespec] any_:expr apply:record[gen:du parms:sequence[expr]] asis:string bad:null bool_:bool cand_:record[left:expr right:expr] char_:char cor_:record[left:expr right:expr] down_:expr fetch:record[index:expr object:expr] force_:typespec get:record[object:expr sel:string] idn:idn infix:record[left:expr neg:bool op:string right:expr] int_:int invoke:record[apply:expr args:sequence[expr] line:int] minus:expr not:expr null_:null op:record[name:string parms:sequence[expr] type_:typespec] real_:real ref:record[idn:idn parms:sequence[expr]] s_cons:record[fields:sequence[record[line:int sels:sequence[string] val:expr]] type_:typespec] send:record[args:sequence[expr] object:expr params:sequence[expr] sel:string] str:string type_:typespec type_of_:expr up_:expr] exprkey:oneof[down_:null force_:null type_of_:null up_:null] has_:null idn:idn in_:null is_:null l_bkt:null l_curly:null l_paren:null not:null op:struct[neg:bool op:string prec:int] others_:null period:null r_bkt:null r_curly:null r_paren:null resignal_:null returns_:null semi:null sharp:null signals_:null stmtkey:oneof[begin_:null break_:null continue_:null exit_:null for_:null if_:null own_:null return_:null signal_:null tagcase_:null while_:null yield_:null] tag_:null then_:null type_:typespec typekey:oneof[applytype_:du cluster_:du rep_:idn selector_:du] when_:null where_:null yields_:null]]],bind,no_param*/
/* depend,init_klist*/

#include <clu2c.h>

static bool	IV_IN_Cjkindlist = FALSE;
static object	WVchrvec_IN_Cp__env;
extern object	PV1_INjkindlist_Dfetch;
extern object	PV2_INjkindlist_Dfetch;
extern object	PV1_INjkindlist_Dnew;
extern object	PV2_INjkindlist_Dnew;
extern object	PV3_INjkindlist_Dnew;
extern object	PV4_INjkindlist_Dnew;
extern object	PV5_INjkindlist_Dnew;
static object	WVchrvec_IN_Cjkindlist;
extern int	OFint_Dequal();
static bool	IV_IN_Cp__env = FALSE;
extern int	OFjkindlist_Dhash__int();
static object	WVscharlist_IN_Cjkindlist;
static object	WVucharlist_IN_Cjkindlist;

static STRING_REP(1) str1 = {1, {'('}};
static STRING_REP(2) str2 = {2, {')', ' '}};
static STRING_REP(2) str3 = {2, {':', '\t'}};
static STRING_REP(8) str4 = {8, {'m', 'i', 's', 's', 'i', 'n', 'g', ' '}};
static STRING_REP(18) str5 = {18, {' ', '-', ' ', 'a', 's', 's', 'u', 'm', 'e', 'd', ' ', 'p', 'r', 'e', 's', 'e', 'n', 't'}};
static STRING_REP(3) str6 = {3, {'<', '!', '>'}};
static STRING_REP(2) str7 = {2, {'\n', '\t'}};
static STRING_REP(25) str8 = {25, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 't', 'e', 'x', 't'}};
static STRING_REP(6) str9 = {6, {'a', 'b', 'c', 'd', 'e', 'f'}};
static STRING_REP(24) str10 = {24, {'I', 'n', 't', 'e', 'g', 'e', 'r', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 'e', 'd'}};
static STRING_REP(27) str11 = {27, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'h', 'e', 'x', 'a', 'd', 'e', 'c', 'i', 'm', 'a', 'l', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(21) str12 = {21, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'o', 'c', 't', 'a', 'l', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(3) str13 = {3, {'a', 'd', 'd'}};
static STRING_REP(3) str14 = {3, {'s', 'u', 'b'}};
static STRING_REP(27) str15 = {27, {'B', 'a', 'd', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'f', 'o', 'r', ' ', 'r', 'e', 'a', 'l', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(21) str16 = {21, {'R', 'e', 'a', 'l', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 'e', 'd'}};
static STRING_REP(22) str17 = {22, {'R', 'e', 'a', 'l', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'u', 'n', 'd', 'e', 'r', 'f', 'l', 'o', 'w', 'e', 'd'}};
static STRING_REP(27) str18 = {27, {'U', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', ' ', 's', 't', 'r', 'i', 'n', 'g', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(35) str19 = {35, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 's', 't', 'r', 'i', 'n', 'g', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(22) str20 = {22, {'S', 't', 'r', 'a', 'y', ' ', '\'', ' ', 'a', 't', ' ', 'e', 'n', 'd', ' ', 'o', 'f', ' ', 'l', 'i', 'n', 'e'}};
static STRING_REP(2) str21 = {2, {'\'', '\''}};
static STRING_REP(23) str22 = {23, {'E', 'm', 'p', 't', 'y', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(25) str23 = {25, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(1) str24 = {1, {'\''}};
static STRING_REP(30) str25 = {30, {'U', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l'}};
static STRING_REP(22) str26 = {22, {'S', 't', 'r', 'a', 'y', ' ', '\\', ' ', 'a', 't', ' ', 'e', 'n', 'd', ' ', 'o', 'f', ' ', 'l', 'i', 'n', 'e'}};
static STRING_REP(1) str27 = {1, {'^'}};
static STRING_REP(28) str28 = {28, {'\\', '^', '*', ' ', 'e', 's', 'c', 'a', 'p', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's', ' ', 'i', 'l', 'l', 'e', 'g', 'a', 'l'}};
static STRING_REP(23) str29 = {23, {'S', 't', 'r', 'a', 'y', ' ', '\\', '^', ' ', 'a', 't', ' ', 'e', 'n', 'd', ' ', 'o', 'f', ' ', 'l', 'i', 'n', 'e'}};
static STRING_REP(1) str30 = {1, {'\\'}};
static STRING_REP(23) str31 = {23, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'e', 's', 'c', 'a', 'p', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'}};
static STRING_REP(6) str32 = {6, {'c', 'o', 'n', 'c', 'a', 't'}};
static STRING_REP(5) str33 = {5, {'p', 'o', 'w', 'e', 'r'}};
static STRING_REP(3) str34 = {3, {'m', 'o', 'd'}};
static STRING_REP(2) str35 = {2, {'l', 'e'}};
static STRING_REP(2) str36 = {2, {'g', 'e'}};
static STRING_REP(5) str37 = {5, {'e', 'q', 'u', 'a', 'l'}};
static STRING_REP(2) str38 = {2, {'l', 't'}};
static STRING_REP(2) str39 = {2, {'g', 't'}};
static STRING_REP(28) str40 = {28, {'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'm', 'e', 'n', 't'}};
static STRING_REP(2) str41 = {2, {':', ' '}};
static STRING_REP(2) str42 = {2, {'^', '?'}};
static STRING_REP(1) str43 = {1, {'!'}};
static STRING_REP(1) str44 = {1, {'&'}};
static STRING_REP(3) str45 = {3, {'a', 'n', 'd'}};
static STRING_REP(3) str46 = {3, {'m', 'u', 'l'}};
static STRING_REP(3) str47 = {3, {'d', 'i', 'v'}};
static STRING_REP(2) str48 = {2, {'o', 'r'}};

/* begin module */
/* c_function_name, OFp__env_Dcreate */
/* clu_operation_name, p_env$create */
int OFp__env_Dcreate(LVcomp, LVinst, LVerrst)
     object LVcomp;
     object LVinst;
     object LVerrst;
{
  object LVe= 0;
  int t1, t2, t3, t4, t5, t6, t7, t8;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OFtokentab_Dcreate(LVcomp) == SIG)
    {
      goto except0;
    }
  t1 = retval_area[0];
  OFoneof_Dmake(10, NIL);
  t2 = retval_area[0];
  OFarray_Dpredict(1, 50);
  t3 = retval_area[0];
  OFarray_Dpredict(1, 50);
  t4 = retval_area[0];
  OFarray_Dpredict(1, 50);
  t5 = retval_area[0];
  OFarray_Dpredict(1, 10);
  t6 = retval_area[0];
  OFarray_Dpredict(1, 50);
  t7 = retval_area[0];
  if (OFce_Dget__unknown__type(LVcomp) == SIG)
    {
      goto except0;
    }
  t8 = OFrecord_D__alloc(22);
  OMrecord_Dset(1, t8, SLNULL);
  OMrecord_Dset(2, t8, t6);
  OMrecord_Dset(3, t8, LVcomp);
  OMrecord_Dset(4, t8, SLNULL);
  OMrecord_Dset(5, t8, 0);
  OMrecord_Dset(6, t8, LVerrst);
  OMrecord_Dset(7, t8, SLNULL);
  OMrecord_Dset(8, t8, FALSE);
  OMrecord_Dset(9, t8, 0);
  OMrecord_Dset(10, t8, LVinst);
  OMrecord_Dset(11, t8, 1);
  OMrecord_Dset(12, t8, 1);
  OMrecord_Dset(13, t8, t4);
  OMrecord_Dset(14, t8, t5);
  OMrecord_Dset(15, t8, t2);
  OMrecord_Dset(16, t8, t3);
  OMrecord_Dset(17, t8, FALSE);
  OMrecord_Dset(18, t8, TRUE);
  OMrecord_Dset(19, t8, FALSE);
  OMrecord_Dset(20, t8, t7);
  OMrecord_Dset(21, t8, t1);
  OMrecord_Dset(22, t8, retval_area[0]);
  LVe = t8;
  if (OFp__env_Dnext__token(LVe) == SIG)
    {
      goto except0;
    }
  t1 = OMrecord_Dget(15, LVe);
  t2 = ((oneof) t1)->tag;
  if (t2 == 10)
    {
        {
        }
    }
  else
    {
      OMrecord_Dset(18, LVe, FALSE);
    }
  if (OFarray_Dtrim(OMrecord_Dget(14, LVe), 1, 0) == SIG)
    {
      goto except0;
    }
  retval_area[0] = LVe;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dnew__env */
/* clu_operation_name, p_env$new_env */
int OFp__env_Dnew__env(LVe, LVinst)
     object LVe;
     object LVinst;
{
  object LVe1= 0;
  int t1, t2;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMrecord_Dset(18, LVe, FALSE);
  OFrecord_Dcopy1(LVe);
  LVe1 = retval_area[0];
  OMrecord_Dset(10, LVe1, LVinst);
  if (OFstream_Dget__name(LVinst) == SIG)
    {
      goto except0;
    }
  if (OFfile__name_Dunparse(retval_area[0]) == SIG)
    {
      goto except0;
    }
  t1 = OMstring_Dsize(((string) &str1))
       + OMstring_Dsize(retval_area[0])
       + OMstring_Dsize(((string) &str2));
  t2 = OFstring_D__predict(t1);
  OFstring_D__concat(t2, ((string) &str1));
  OFstring_D__concat(t2, retval_area[0]);
  OFstring_D__concat(t2, ((string) &str2));
  OMrecord_Dset(7, LVe1, t2);
  OMrecord_Dset(12, LVe1, 1);
  OMrecord_Dset(9, LVe1, 0);
  OFarray_Dpredict(1, 50);
  OMrecord_Dset(16, LVe1, retval_area[0]);
  OFarray_Dpredict(1, 50);
  OMrecord_Dset(13, LVe1, retval_area[0]);
  OFarray_Dpredict(1, 50);
  OMrecord_Dset(14, LVe1, retval_area[0]);
  if (OFp__env_Dnext__token(LVe1) == SIG)
    {
      goto except0;
    }
  if (OFarray_Dtrim(OMrecord_Dget(14, LVe1), 1, 0) == SIG)
    {
      goto except0;
    }
  retval_area[0] = LVe1;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dreset */
/* clu_operation_name, p_env$reset */
int OFp__env_Dreset(LVe, LVcomp, LVinst, LVerrst)
     object LVe;
     object LVcomp;
     object LVinst;
     object LVerrst;
{
  int t1, t2;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMrecord_Dset(3, LVe, LVcomp);
  OMrecord_Dset(6, LVe, LVerrst);
  OMrecord_Dset(5, LVe, 0);
  OMrecord_Dset(10, LVe, LVinst);
  OMrecord_Dset(12, LVe, 1);
  OMrecord_Dset(9, LVe, 0);
  if (OMbool_Dnot(OMrecord_Dget(18, LVe)))
    {
      if (OFtokentab_Dreset(OMrecord_Dget(21, LVe), LVcomp) == SIG)
        {
	  goto except0;
        }
      OMrecord_Dset(8, LVe, FALSE);
      OMarray_Dset__low(OMrecord_Dget(16, LVe), 1);
      if (OFarray_Dtrim(OMrecord_Dget(16, LVe), 1, 0) == SIG)
        {
	  goto except0;
        }
      OMarray_Dset__low(OMrecord_Dget(13, LVe), 1);
      if (OFarray_Dtrim(OMrecord_Dget(13, LVe), 1, 0) == SIG)
        {
	  goto except0;
        }
      if (OFarray_Dtrim(OMrecord_Dget(2, LVe), 1, 0) == SIG)
        {
	  goto except0;
        }
      if (OFce_Dget__unknown__type(LVcomp) == SIG)
        {
	  goto except0;
        }
      OMrecord_Dset(22, LVe, retval_area[0]);
    }
  if (OFp__env_Dnext__token(LVe) == SIG)
    {
      goto except0;
    }
  t1 = OMrecord_Dget(15, LVe);
  t2 = ((oneof) t1)->tag;
  if (t2 == 10)
    {
        {
	  OMrecord_Dset(18, LVe, TRUE);
        }
    }
  else
    {
      OMrecord_Dset(18, LVe, FALSE);
    }
  if (OFarray_Dtrim(OMrecord_Dget(14, LVe), 1, 0) == SIG)
    {
      goto except0;
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dhack */
/* clu_operation_name, p_env$hack */
int OFp__env_Dhack(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMbool_Dnot(OMrecord_Dget(8, LVe)))
    {
      OMrecord_Dset(8, LVe, TRUE);
      if (OFtokentab_Dhack(OMrecord_Dget(21, LVe)) == SIG)
        {
	  goto except0;
        }
      OMrecord_Dset(18, LVe, FALSE);
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dunhack */
/* clu_operation_name, p_env$unhack */
int OFp__env_Dunhack(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMrecord_Dget(8, LVe))
    {
      OMrecord_Dset(8, LVe, FALSE);
      if (OFtokentab_Dunhack(OMrecord_Dget(21, LVe)) == SIG)
        {
	  goto except0;
        }
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dis__hacked */
/* clu_operation_name, p_env$is_hacked */
int OFp__env_Dis__hacked(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(8, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dadd__token */
/* clu_operation_name, p_env$add_token */
int OFp__env_Dadd__token(LVe, LVn, LVk)
     object LVe;
     object LVn;
     object LVk;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OFtokentab_Dadd__token(OMrecord_Dget(21, LVe), LVn, LVk) == SIG)
    {
      goto except0;
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__peek1 */
/* clu_operation_name, p_env$get_peek1 */
int OFp__env_Dget__peek1(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(15, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dpeek */
/* clu_operation_name, p_env$peek */
int OFp__env_Dpeek(LVe, LVnum)
     object LVe;
     object LVnum;
{
  object LVsp= 0;
  int t1;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMint_Dequal(LVnum, 1))
    {
      retval_area[0] = OMrecord_Dget(15, LVe);
      return RET;
    }
  LVnum = OMint_Dsub(LVnum, 2);
  LVsp = OMrecord_Dget(16, LVe);
  while (TRUE)
    {
      if (!OMint_Dle(OMarray_Dsize(LVsp), LVnum))
        {
	  break;
        }
        {
	  if (OFp__env_Dscanline(LVe) == SIG)
	    {
	      goto except0;
	    }
        }
    }
  t1 = OMint_Dadd(OMarray_Dlow(LVsp), LVnum);
  if (OMarray_Dbounds(LVsp, t1))
    {
      signame = SLBOUNDS;
      goto except0;
    }
  retval_area[0] = OMarray_Dfetch(LVsp, t1);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dnext__token */
/* clu_operation_name, p_env$next_token */
int OFp__env_Dnext__token(LVe)
     object LVe;
{
  object LVsp= 0;
  object LVlnum= 0;
  object LVk= 0;
  int t1;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVsp = OMrecord_Dget(16, LVe);
  if (OMarray_Dempty(LVsp))
    {
      if (OFp__env_Dscanline(LVe) == SIG)
        {
	  goto except0;
        }
    }
  LVlnum = OMrecord_Dget(12, LVe);
  if (OMint_Dgt(LVlnum, OMrecord_Dget(11, LVe)))
    {
      if (OFarray_Dtrim(OMrecord_Dget(14, LVe), 1, 0) == SIG)
        {
	  goto except0;
        }
    }
  OMrecord_Dset(11, LVe, LVlnum);
  LVk = OMrecord_Dget(15, LVe);
  OMarray_Daddh(OMrecord_Dget(14, LVe), LVk);
  if (OMarray_Dempty(LVsp))
    {
      signame = SLBOUNDS;
      goto except0;
    }
  OMrecord_Dset(15, LVe, OMarray_Dreml(LVsp));
  t1 = OMrecord_Dget(13, LVe);
  if (OMarray_Dempty(t1))
    {
      signame = SLBOUNDS;
      goto except0;
    }
  OMrecord_Dset(12, LVe, OMarray_Dreml(t1));
  retval_area[0] = LVk;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__line */
/* clu_operation_name, p_env$get_line */
int OFp__env_Dget__line(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(11, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__peekline */
/* clu_operation_name, p_env$get_peekline */
int OFp__env_Dget__peekline(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(12, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dbegin__body */
/* clu_operation_name, p_env$begin_body */
int OFp__env_Dbegin__body(LVe, LVkind)
     object LVe;
     object LVkind;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMarray_Daddh(OMrecord_Dget(2, LVe), LVkind);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dend__body */
/* clu_operation_name, p_env$end_body */
int OFp__env_Dend__body(LVe)
     object LVe;
{
  int t1;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  t1 = OMrecord_Dget(2, LVe);
  if (OMarray_Dempty(t1))
    {
      signame = SLBOUNDS;
      goto except0;
    }
  OMarray_Dremh(t1);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Din__body */
/* clu_operation_name, p_env$in_body */
int OFp__env_Din__body(LVe, LVkind)
     object LVe;
     object LVkind;
{
  int t1, t2, t3;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
    {
      object LVk= 0;
      for (t1 = OMrecord_Dget(2, LVe), t2 = OMarray_Dlow(t1), t3 = OMarray_Dhigh(t1);
           t2 <= t3;
           t2++)
        {
	  LVk = OMarray_Dfetch(t1, t2);
	    {
	      if (OMint_Dequal(LVk, LVkind))
	        {
		  retval_area[0] = TRUE;
		  return RET;
	        }
	    }
        }
    }
  retval_area[0] = FALSE;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__unknown__type */
/* clu_operation_name, p_env$get_unknown_type */
int OFp__env_Dget__unknown__type(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(22, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__bad__expr */
/* clu_operation_name, p_env$get_bad_expr */
int OFp__env_Dget__bad__expr(LVe)
     object LVe;
{
  int t1;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OFoneof_Dmake(5, NIL);
  t1 = retval_area[0];
  if (OFexpr_Dcreate(t1, OMrecord_Dget(22, LVe)) == SIG)
    {
      goto except0;
    }
  retval_area[0] = retval_area[0];
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dassume */
/* clu_operation_name, p_env$assume */
int OFp__env_Dassume(LVe, LVwhat)
     object LVe;
     object LVwhat;
{
  object LVst= 0;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(6, LVe);
    {
      OFint_Dunparse(OMrecord_Dget(11, LVe));
      if (OFstream_Dputs(LVst, retval_area[0]) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, ((string) &str3)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, OMrecord_Dget(7, LVe)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, ((string) &str4)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, LVwhat) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, ((string) &str5)) == SIG)
        {
	  goto except1;
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLNOT_POSSIBLE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (OFp__env_Dline(LVe, 1) == SIG)
    {
      goto except0;
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__err */
/* clu_operation_name, p_env$get_err */
int OFp__env_Dget__err(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(5, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dset__err */
/* clu_operation_name, p_env$set_err */
int OFp__env_Dset__err(LVe, LVdeg)
     object LVe;
     object LVdeg;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMint_Dgt(LVdeg, OMrecord_Dget(5, LVe)))
    {
      OMrecord_Dset(5, LVe, LVdeg);
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dreset__err */
/* clu_operation_name, p_env$reset_err */
int OFp__env_Dreset__err(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMrecord_Dset(5, LVe, 0);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Derr */
/* clu_operation_name, p_env$err */
int OFp__env_Derr(LVe, LVwhy, LVdeg)
     object LVe;
     object LVwhy;
     object LVdeg;
{
  object LVst= 0;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(6, LVe);
    {
      OFint_Dunparse(OMrecord_Dget(11, LVe));
      if (OFstream_Dputs(LVst, retval_area[0]) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, ((string) &str3)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, OMrecord_Dget(7, LVe)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, LVwhy) == SIG)
        {
	  goto except1;
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLNOT_POSSIBLE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (OFp__env_Dline(LVe, LVdeg) == SIG)
    {
      goto except0;
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dline */
/* clu_operation_name, p_env$line */
int OFp__env_Dline(LVe, LVdeg)
     object LVe;
     object LVdeg;
{
  object LVst= 0;
  int t1, t2, t3;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(6, LVe);
    {
      object LVsp= 0;
      object LVlines= 0;
      if (OFstream_Dputc(LVst, '\n') == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputc(LVst, '\t') == SIG)
        {
	  goto except1;
        }
        {
	  object LVk= 0;
	  for (t1 = OMrecord_Dget(14, LVe), t2 = OMarray_Dlow(t1), t3 = OMarray_Dhigh(t1);
	       t2 <= t3;
	       t2++)
	    {
	      LVk = OMarray_Dfetch(t1, t2);
	        {
		  if (AFpt__token(LVk, LVst) == SIG)
		    {
		      goto except1;
		    }
		  if (OFstream_Dputc(LVst, ' ') == SIG)
		    {
		      goto except1;
		    }
	        }
	    }
        }
      if (OFstream_Dputs(LVst, ((string) &str6)) == SIG)
        {
	  goto except1;
        }
      t1 = OMrecord_Dget(12, LVe);
      if (OMint_Dgt(t1, OMrecord_Dget(11, LVe)))
        {
	  if (OFstream_Dputs(LVst, ((string) &str7)) == SIG)
	    {
	      goto except1;
	    }
        }
      else
        {
	  if (OFstream_Dputc(LVst, ' ') == SIG)
	    {
	      goto except1;
	    }
        }
      if (AFpt__token(OMrecord_Dget(15, LVe), LVst) == SIG)
        {
	  goto except1;
        }
      LVsp = OMrecord_Dget(16, LVe);
      LVlines = OMrecord_Dget(13, LVe);
        {
	  object LVi= 0;
	  for (t1 = OMarray_Dlow(LVlines), t2 = OMarray_Dhigh(LVlines); t1 <= t2; t1++)
	    {
	      LVi = t1;
	        {
		  if (OMarray_Dbounds(LVlines, LVi))
		    {
		      signame = SLBOUNDS;
		      goto except1;
		    }
		  t3 = OMarray_Dfetch(LVlines, LVi);
		  if (OMint_Dgt(t3, OMrecord_Dget(12, LVe)))
		    {
		      break;
		    }
		  if (OFstream_Dputc(LVst, ' ') == SIG)
		    {
		      goto except1;
		    }
		  if (OMarray_Dbounds(LVsp, LVi))
		    {
		      signame = SLBOUNDS;
		      goto except1;
		    }
		  if (AFpt__token(OMarray_Dfetch(LVsp, LVi), LVst) == SIG)
		    {
		      goto except1;
		    }
	        }
	    }
        }
      if (OFstream_Dputc(LVst, '\n') == SIG)
        {
	  goto except1;
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLNOT_POSSIBLE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (OMint_Dgt(LVdeg, OMrecord_Dget(5, LVe)))
    {
      OMrecord_Dset(5, LVe, LVdeg);
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dset__deftype */
/* clu_operation_name, p_env$set_deftype */
int OFp__env_Dset__deftype(LVe, LVwhich, LVspecvals)
     object LVe;
     object LVwhich;
     object LVspecvals;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OFce_Dget__proc__(OMrecord_Dget(3, LVe)) == SIG)
    {
      goto except0;
    }
  if (OFdu_Dequal(LVwhich, retval_area[0]) == SIG)
    {
      goto except0;
    }
  OMrecord_Dset(17, LVe, retval_area[0]);
  OMrecord_Dset(19, LVe, LVspecvals);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Din__proc */
/* clu_operation_name, p_env$in_proc */
int OFp__env_Din__proc(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(17, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dspecd__vals */
/* clu_operation_name, p_env$specd_vals */
int OFp__env_Dspecd__vals(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(19, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__clustr */
/* clu_operation_name, p_env$get_clustr */
int OFp__env_Dget__clustr(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(4, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dget__applystr */
/* clu_operation_name, p_env$get_applystr */
int OFp__env_Dget__applystr(LVe)
     object LVe;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  retval_area[0] = OMrecord_Dget(1, LVe);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dset__clustr */
/* clu_operation_name, p_env$set_clustr */
int OFp__env_Dset__clustr(LVe, LVs)
     object LVe;
     object LVs;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMrecord_Dset(4, LVe, LVs);
  OMrecord_Dset(18, LVe, FALSE);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dset__applystr */
/* clu_operation_name, p_env$set_applystr */
int OFp__env_Dset__applystr(LVe, LVs)
     object LVe;
     object LVs;
{
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  OMrecord_Dset(1, LVe, LVs);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dscanline */
/* clu_operation_name, p_env$scanline */
int OFp__env_Dscanline(LVe)
     object LVe;
{
  object LVtokens= 0;
  object LVst= 0;
  object LVsp= 0;
  object LVlines= 0;
  object LVz= 0;
  int t1, t2, t3;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVtokens = OMrecord_Dget(21, LVe);
  LVst = OMrecord_Dget(10, LVe);
  LVsp = OMrecord_Dget(16, LVe);
  LVlines = OMrecord_Dget(13, LVe);
  LVz = OMarray_Dsize(LVsp);
  OMrecord_Dset(9, LVe, OMint_Dadd(OMrecord_Dget(9, LVe), 1));
  while (TRUE)
    {
        {
	  object LVcc= 0;
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  LVcc = retval_area[0];
	  if (FALSE)
	    {
	    except1:
	      if (OMstring_Dequal(signame, SLEND_OF_FILE))
	        {
		  OFoneof_Dmake(10, NIL);
		  OMarray_Daddh(LVsp, retval_area[0]);
		  LVcc = '\n';
	        }
	      else
	        {
		  goto except0;
	        }
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(LVcc)) == SIG)
	    {
	      goto except2;
	    }
	  t1 = ((oneof) retval_area[0])->tag;
	  if (t1 == 8)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  if (OFp__env_Didn__or__key(LVe, LVc) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else if (t1 == 1)
	    {
	        {
	        }
	    }
	  else if (t1 == 12)
	    {
	      object LVt= 0;
	      LVt = ((oneof) retval_area[0])->value;
	        {
		  OMarray_Daddh(LVsp, LVt);
	        }
	    }
	  else if (t1 == 9)
	    {
	      object LVt= 0;
	      LVt = ((oneof) retval_area[0])->value;
	        {
		  if (OFp__env_Dmcharop(LVe, LVt) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else if (t1 == 3)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  if (OFp__env_Dnumber(LVe, LVc) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else if (t1 == 11)
	    {
	        {
		  if (OFp__env_Dstrlit(LVe) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else if (t1 == 10)
	    {
	        {
		  if (OFp__env_Dcharlit(LVe) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else if (t1 == 4)
	    {
	        {
		  object LVz1= 0;
		  object LViline= 0;
		  LVz1 = OMarray_Dsize(LVsp);
		  LViline = OMrecord_Dget(9, LVe);
		  if (OMint_Dlt(LVz, LVz1))
		    {
		      for (t2 = OMint_Dadd(LVz, 1), t3 = LVz1; t2 <= t3; t2++)
		        {
			  LVz = t2;
			    {
			      OMarray_Daddh(LVlines, LViline);
			    }
		        }
		      return RET;
		    }
		  else
		    {
		      OMrecord_Dset(9, LVe, OMint_Dadd(LViline, 1));
		    }
	        }
	    }
	  else if (t1 == 2)
	    {
	        {
		  if (OFp__env_Dcomment(LVe) == SIG)
		    {
		      goto except2;
		    }
	        }
	    }
	  else
	    {
	      if (AFcprint__form(LVcc) == SIG)
	        {
		  goto except2;
	        }
	      if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str8)) == SIG)
	        {
		  goto except2;
	        }
	    }
	  if (FALSE)
	    {
	    except2:
	      if (OMstring_Dequal(signame, SLBOUNDS))
	        {
		  if (AFcprint__form(LVcc) == SIG)
		    {
		      goto except0;
		    }
		  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str8)) == SIG)
		    {
		      goto except0;
		    }
	        }
	      else
	        {
		  goto except0;
	        }
	    }
        }
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Didn__or__key */
/* clu_operation_name, p_env$idn_or_key */
int OFp__env_Didn__or__key(LVe, LVcc)
     object LVe;
     object LVcc;
{
  object LVst= 0;
  object LVt= 0;
  int t1, t2;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  LVt = OMrecord_Dget(20, LVe);
  if (OFarray_Dtrim(LVt, 1, 0) == SIG)
    {
      goto except0;
    }
  OMarray_Daddh(LVt, LVcc);
  while (TRUE)
    {
        {
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t1 = ((oneof) retval_area[0])->tag;
	  if (t1 == 8 || t1 == 3)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  OMarray_Daddh(LVt, LVc);
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
	        }
	    }
	  else
	    {
	      break;
	    }
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS) || OMstring_Dequal(signame, SLEND_OF_FILE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  t1 = OMrecord_Dget(16, LVe);
  t2 = OMrecord_Dget(21, LVe);
  OFstring_Dac2s(LVt);
  if (OFtokentab_Dget__token(t2, retval_area[0]) == SIG)
    {
      goto except0;
    }
  OMarray_Daddh(t1, retval_area[0]);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dnumber */
/* clu_operation_name, p_env$number */
int OFp__env_Dnumber(LVe, LVcc)
     object LVe;
     object LVcc;
{
  object LVst= 0;
  object LVb= 0;
  object LVhexadecimal= 0;
  object LVres= 0;
  object LVs= 0;
  int t1, t2, t3, t4;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  LVb = OMrecord_Dget(20, LVe);
  if (OFarray_Dtrim(LVb, 1, 0) == SIG)
    {
      goto except0;
    }
  OMarray_Daddh(LVb, LVcc);
  LVhexadecimal = FALSE;
  while (TRUE)
    {
        {
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t1 = ((oneof) retval_area[0])->tag;
	  if (t1 == 3)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  OMarray_Daddh(LVb, LVc);
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
		  continue;
	        }
	    }
	  else if (t1 == 8)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  t2 = FALSE;
		  if (OMchar_Dequal(LVc, 'e'))
		    {
		      if (OMbool_Dnot(LVhexadecimal))
		        {
			  t2 = TRUE;
		        }
		    }
		  if (t2)
		    {
		      if (OFp__env_Dreallit(LVe, LVb) == SIG)
		        {
			  goto except1;
		        }
		      return RET;
		    }
		  else
		    {
		      t3 = FALSE;
		      if (LVhexadecimal)
		        {
			  OFstring_Dindexc(LVc, ((string) &str9));
			  if (OMint_Dgt(retval_area[0], 0))
			    {
			      t3 = TRUE;
			    }
		        }
		      if (t3)
		        {
			  OMarray_Daddh(LVb, LVc);
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  continue;
		        }
		      else
		        {
			  t4 = FALSE;
			  if (OMchar_Dequal(LVc, 'x'))
			    {
			      if (OMint_Dequal(OMarray_Dsize(LVb), 1))
			        {
				  t4 = TRUE;
			        }
			    }
			  if (t4)
			    {
			      LVhexadecimal = TRUE;
			      if (OFstream_Dgetc(LVst) == SIG)
			        {
				  goto except1;
			        }
			    }
			  else
			    {
			      break;
			    }
		        }
		    }
	        }
	    }
	  else if (t1 == 9)
	    {
	      object LVt= 0;
	      LVt = ((oneof) retval_area[0])->value;
	        {
		  t2 = ((oneof) LVt)->tag;
		  if (t2 == 5)
		    {
		        {
			  OMarray_Daddh(LVb, '.');
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  if (OFp__env_Dreallit(LVe, LVb) == SIG)
			    {
			      goto except1;
			    }
			  return RET;
		        }
		    }
		  else
		    {
		      break;
		    }
	        }
	    }
	  else
	    {
	      break;
	    }
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS) || OMstring_Dequal(signame, SLEND_OF_FILE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  OFstring_Dac2s(LVb);
  LVs = retval_area[0];
  if (OMbool_Dnot(OMchar_Dequal(LVcc, '0')))
    {
      t1 = TRUE;
    }
  else
    {
      t1 = OMbool_Dnot(OMrecord_Dget(8, LVe));
    }
  if (t1)
    {
      if (OFint_Dparse(LVs) == SIG)
        {
	  goto except2;
        }
      LVres = retval_area[0];
    }
  else
    {
      if (LVhexadecimal)
        {
	  if (AFint__hex__parse(LVs) == SIG)
	    {
	      goto except2;
	    }
	  LVres = retval_area[0];
        }
      else
        {
	  if (AFint__oct__parse(LVs) == SIG)
	    {
	      goto except2;
	    }
	  LVres = retval_area[0];
        }
    }
  if (FALSE)
    {
    except2:
      if (OMstring_Dequal(signame, SLOVERFLOW))
        {
	  if (OFp__env_Dbad(LVe, LVs, ((string) &str10)) == SIG)
	    {
	      goto except0;
	    }
	  LVres = 131071;
        }
      else if (OMstring_Dequal(signame, SLBAD_FORMAT))
        {
	  if (LVhexadecimal)
	    {
	      if (OFp__env_Dbad(LVe, LVs, ((string) &str11)) == SIG)
	        {
		  goto except0;
	        }
	    }
	  else
	    {
	      if (OFp__env_Dbad(LVe, LVs, ((string) &str12)) == SIG)
	        {
		  goto except0;
	        }
	    }
	  LVres = 0;
        }
      else
        {
	  goto except0;
        }
    }
  t1 = OMrecord_Dget(16, LVe);
  OFoneof_Dmake(16, LVres);
  OFoneof_Dmake(14, retval_area[0]);
  OMarray_Daddh(t1, retval_area[0]);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dreallit */
/* clu_operation_name, p_env$reallit */
int OFp__env_Dreallit(LVe, LVa)
     object LVe;
     object LVa;
{
  object LVst= 0;
  object LVnoexp= 0;
  object LVlit= 0;
  object LVres= 0;
  int t1, t2, t3, t4;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  LVnoexp = TRUE;
  while (TRUE)
    {
        {
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t1 = ((oneof) retval_area[0])->tag;
	  if (t1 == 3)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  OMarray_Daddh(LVa, LVc);
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
	        }
	    }
	  else if (t1 == 8)
	    {
	      object LVc= 0;
	      LVc = ((oneof) retval_area[0])->value;
	        {
		  t2 = FALSE;
		  if (OMchar_Dequal(LVc, 'e'))
		    {
		      if (LVnoexp)
		        {
			  t2 = TRUE;
		        }
		    }
		  if (t2)
		    {
		      LVnoexp = FALSE;
		      OMarray_Daddh(LVa, LVc);
		      if (OFstream_Dgetc(LVst) == SIG)
		        {
			  goto except1;
		        }
		      if (OFstream_Dpeekc(LVst) == SIG)
		        {
			  goto except1;
		        }
		      if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
		        {
			  goto except1;
		        }
		      t3 = ((oneof) retval_area[0])->tag;
		      if (t3 == 12)
		        {
			  object LVt= 0;
			  LVt = ((oneof) retval_area[0])->value;
			    {
			      t4 = ((oneof) LVt)->tag;
			      if (t4 == 24)
			        {
				  object LVk= 0;
				  LVk = ((oneof) LVt)->value;
				    {
				      object LVn= 0;
				      LVn = OMstruct_Dget(2, LVk);
				      if (OMstring_Dequal(LVn, ((string) &str13)))
				        {
					  OMarray_Daddh(LVa, '+');
					  if (OFstream_Dgetc(LVst) == SIG)
					    {
					      goto except1;
					    }
				        }
				      else
				        {
					  if (OMstring_Dequal(LVn, ((string) &str14)))
					    {
					      OMarray_Daddh(LVa, '-');
					      if (OFstream_Dgetc(LVst) == SIG)
					        {
						  goto except1;
					        }
					    }
				        }
				    }
			        }
			    }
		        }
		    }
		  else
		    {
		      break;
		    }
	        }
	    }
	  else
	    {
	      break;
	    }
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS) || OMstring_Dequal(signame, SLEND_OF_FILE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  OFstring_Dac2s(LVa);
  LVlit = retval_area[0];
  if (OFreal_Dparse(LVlit) == SIG)
    {
      goto except2;
    }
  LVres = retval_area[0];
  if (FALSE)
    {
    except2:
      if (OMstring_Dequal(signame, SLBAD_FORMAT))
        {
	  if (OFp__env_Dbad(LVe, LVlit, ((string) &str15)) == SIG)
	    {
	      goto except0;
	    }
	  LVres = OFreal_Dlit(1.e+38);
        }
      else if (OMstring_Dequal(signame, SLOVERFLOW))
        {
	  if (OFp__env_Dbad(LVe, LVlit, ((string) &str16)) == SIG)
	    {
	      goto except0;
	    }
	  LVres = OFreal_Dlit(1.e+38);
        }
      else if (OMstring_Dequal(signame, SLUNDERFLOW))
        {
	  if (OFp__env_Dbad(LVe, LVlit, ((string) &str17)) == SIG)
	    {
	      goto except0;
	    }
	  LVres = OFreal_Dlit(0.);
        }
      else
        {
	  goto except0;
        }
    }
  t1 = OMrecord_Dget(16, LVe);
  OFoneof_Dmake(22, LVres);
  OFoneof_Dmake(14, retval_area[0]);
  OMarray_Daddh(t1, retval_area[0]);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dstrlit */
/* clu_operation_name, p_env$strlit */
int OFp__env_Dstrlit(LVe)
     object LVe;
{
  object LVst= 0;
  object LVt= 0;
  int t1;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  LVt = OMrecord_Dget(20, LVe);
  if (OFarray_Dtrim(LVt, 1, 0) == SIG)
    {
      goto except0;
    }
  while (TRUE)
    {
        {
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t1 = ((oneof) retval_area[0])->tag;
	  if (t1 == 11)
	    {
	        {
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
		  break;
	        }
	    }
	  else if (t1 == 5)
	    {
	        {
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
		  if (OFp__env_Descape(LVe) == SIG)
		    {
		      goto except1;
		    }
		  OMarray_Daddh(LVt, retval_area[0]);
	        }
	    }
	  else if (t1 == 4)
	    {
	        {
		  OFstring_Dac2s(LVt);
		  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str18)) == SIG)
		    {
		      goto except1;
		    }
		  break;
	        }
	    }
	  else if (t1 == 7)
	    {
	        {
		  object LVc= 0;
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
		  LVc = retval_area[0];
		  if (AFcprint__form(LVc) == SIG)
		    {
		      goto except1;
		    }
		  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str19)) == SIG)
		    {
		      goto except1;
		    }
		  OMarray_Daddh(LVt, LVc);
	        }
	    }
	  else if (t1 == 1)
	    {
	      object LVis__space= 0;
	      LVis__space = ((oneof) retval_area[0])->value;
	        {
		  object LVc= 0;
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
		  LVc = retval_area[0];
		  if (OMbool_Dnot(LVis__space))
		    {
		      if (AFcprint__form(LVc) == SIG)
		        {
			  goto except1;
		        }
		      if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str19)) == SIG)
		        {
			  goto except1;
		        }
		    }
		  OMarray_Daddh(LVt, LVc);
	        }
	    }
	  else
	    {
	      if (OFstream_Dgetc(LVst) == SIG)
	        {
		  goto except1;
	        }
	      OMarray_Daddh(LVt, retval_area[0]);
	    }
	  if (FALSE)
	    {
	    except1:
	      if (OMstring_Dequal(signame, SLBOUNDS))
	        {
		  object LVc= 0;
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except0;
		    }
		  LVc = retval_area[0];
		  if (AFcprint__form(LVc) == SIG)
		    {
		      goto except0;
		    }
		  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str19)) == SIG)
		    {
		      goto except0;
		    }
		  OMarray_Daddh(LVt, LVc);
	        }
	      else if (OMstring_Dequal(signame, SLEND_OF_FILE))
	        {
		  OFstring_Dac2s(LVt);
		  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str18)) == SIG)
		    {
		      goto except0;
		    }
		  break;
	        }
	      else
	        {
		  goto except0;
	        }
	    }
        }
    }
  t1 = OMrecord_Dget(16, LVe);
  OFstring_Dac2s(LVt);
  OFoneof_Dmake(26, retval_area[0]);
  OFoneof_Dmake(14, retval_area[0]);
  OMarray_Daddh(t1, retval_area[0]);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dcharlit */
/* clu_operation_name, p_env$charlit */
int OFp__env_Dcharlit(LVe)
     object LVe;
{
  object LVst= 0;
  object LVc= 0;
  int t1, t2;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  if (OFstream_Dpeekc(LVst) == SIG)
    {
      goto except1;
    }
  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
    {
      goto except1;
    }
  t1 = ((oneof) retval_area[0])->tag;
  if (t1 == 5)
    {
        {
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFp__env_Descape(LVe) == SIG)
	    {
	      goto except1;
	    }
	  LVc = retval_area[0];
        }
    }
  else if (t1 == 4)
    {
        {
	  if (OFp__env_Dbad(LVe, SLNULL, ((string) &str20)) == SIG)
	    {
	      goto except1;
	    }
	  return RET;
        }
    }
  else if (t1 == 10)
    {
        {
	  if (OFp__env_Dbad(LVe, ((string) &str21), ((string) &str22)) == SIG)
	    {
	      goto except1;
	    }
	  LVc = '?';
        }
    }
  else if (t1 == 7)
    {
        {
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  LVc = retval_area[0];
	  if (AFcprint__form(LVc) == SIG)
	    {
	      goto except1;
	    }
	  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str23)) == SIG)
	    {
	      goto except1;
	    }
        }
    }
  else if (t1 == 1)
    {
      object LVis__space= 0;
      LVis__space = ((oneof) retval_area[0])->value;
        {
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  LVc = retval_area[0];
	  if (OMbool_Dnot(LVis__space))
	    {
	      if (AFcprint__form(LVc) == SIG)
	        {
		  goto except1;
	        }
	      if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str23)) == SIG)
	        {
		  goto except1;
	        }
	    }
        }
    }
  else
    {
      if (OFstream_Dgetc(LVst) == SIG)
        {
	  goto except1;
        }
      LVc = retval_area[0];
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS))
        {
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except0;
	    }
	  LVc = retval_area[0];
	  if (AFcprint__form(LVc) == SIG)
	    {
	      goto except0;
	    }
	  if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str23)) == SIG)
	    {
	      goto except0;
	    }
        }
      else if (OMstring_Dequal(signame, SLEND_OF_FILE))
        {
	  if (OFp__env_Dbad(LVe, SLNULL, ((string) &str20)) == SIG)
	    {
	      goto except0;
	    }
	  return RET;
        }
      else
        {
	  goto except0;
        }
    }
  t1 = OMrecord_Dget(16, LVe);
  OFoneof_Dmake(8, LVc);
  OFoneof_Dmake(14, retval_area[0]);
  OMarray_Daddh(t1, retval_area[0]);
  if (OFstream_Dpeekc(LVst) == SIG)
    {
      goto except2;
    }
  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
    {
      goto except2;
    }
  t1 = ((oneof) retval_area[0])->tag;
  if (t1 == 10)
    {
        {
	  if (OFstream_Dgetc(LVst) == SIG)
	    {
	      goto except2;
	    }
	  return RET;
        }
    }
  if (FALSE)
    {
    except2:
      if (OMstring_Dequal(signame, SLEND_OF_FILE) || OMstring_Dequal(signame, SLBOUNDS))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (AFcprint__form(LVc) == SIG)
    {
      goto except0;
    }
  t1 = OMstring_Dsize(((string) &str24))
       + OMstring_Dsize(retval_area[0]);
  t2 = OFstring_D__predict(t1);
  OFstring_D__concat(t2, ((string) &str24));
  OFstring_D__concat(t2, retval_area[0]);
  if (OFp__env_Dbad(LVe, t2, ((string) &str25)) == SIG)
    {
      goto except0;
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Descape */
/* clu_operation_name, p_env$escape */
int OFp__env_Descape(LVe)
     object LVe;
{
  object LVst= 0;
  object LVk= 0;
  object LVs= 0;
  int t1, t2, t3, t4;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  if (OFstream_Dpeekc(LVst) == SIG)
    {
      goto except1;
    }
  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
    {
      goto except1;
    }
  LVk = retval_area[0];
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS))
        {
	  OFoneof_Dmake(7, NIL);
	  LVk = retval_area[0];
        }
      else if (OMstring_Dequal(signame, SLEND_OF_FILE))
        {
	  OFoneof_Dmake(4, NIL);
	  LVk = retval_area[0];
        }
      else
        {
	  goto except0;
        }
    }
  t1 = ((oneof) LVk)->tag;
  if (t1 == 4)
    {
        {
	  if (OFp__env_Dbad(LVe, SLNULL, ((string) &str26)) == SIG)
	    {
	      goto except0;
	    }
	  retval_area[0] = '?';
	  return RET;
        }
    }
  else
    {
      if (OFstream_Dgetc(LVst) == SIG)
        {
	  goto except0;
        }
      OFstring_Dc2s(retval_area[0]);
      LVs = retval_area[0];
    }
  t1 = ((oneof) LVk)->tag;
  if (t1 == 5 || t1 == 10 || t1 == 11)
    {
        {
	  if (OMstring_Dbounds(LVs, 1))
	    {
	      signame = SLBOUNDS;
	      goto except2;
	    }
	  retval_area[0] = OMstring_Dfetch(LVs, 1);
	  return RET;
        }
    }
  else if (t1 == 8)
    {
      object LVc= 0;
      LVc = ((oneof) LVk)->value;
        {
	  if (OMstring_Dbounds(LVs, 1))
	    {
	      signame = SLBOUNDS;
	      goto except2;
	    }
	  if (OMbool_Dnot(OMchar_Dequal(OMstring_Dfetch(LVs, 1), LVc)))
	    {
	      OFstring_Dc2s(LVc);
	      LVs = retval_area[0];
	    }
	  if (OMchar_Dequal(LVc, 'n'))
	    {
	      retval_area[0] = '\n';
	      return RET;
	    }
	  else
	    {
	      if (OMchar_Dequal(LVc, 't'))
	        {
		  retval_area[0] = '\t';
		  return RET;
	        }
	      else
	        {
		  if (OMchar_Dequal(LVc, 'b'))
		    {
		      retval_area[0] = '\b';
		      return RET;
		    }
		  else
		    {
		      if (OMchar_Dequal(LVc, 'p'))
		        {
			  retval_area[0] = '\f';
			  return RET;
		        }
		      else
		        {
			  if (OMchar_Dequal(LVc, 'r'))
			    {
			      retval_area[0] = '\r';
			      return RET;
			    }
			  else
			    {
			      if (OMchar_Dequal(LVc, 'v'))
			        {
				  retval_area[0] = '\v';
				  return RET;
			        }
			    }
		        }
		    }
	        }
	    }
	  if (OMchar_Dequal(LVc, 'x'))
	    {
	        {
		  object LVi= 0;
		  for (t2 = 1; t2 <= 4; t2++)
		    {
		      LVi = t2;
		        {
			  if (OFstream_Dpeekc(LVst) == SIG)
			    {
			      goto except3;
			    }
			  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
			    {
			      goto except3;
			    }
			  t3 = ((oneof) retval_area[0])->tag;
			  if (t3 == 3)
			    {
			      object LVcc= 0;
			      LVcc = ((oneof) retval_area[0])->value;
			        {
				  OFstring_Dappend(LVs, LVcc);
				  LVs = retval_area[0];
				  if (OFstream_Dgetc(LVst) == SIG)
				    {
				      goto except3;
				    }
			        }
			    }
			  else if (t3 == 8)
			    {
			      object LVcc= 0;
			      LVcc = ((oneof) retval_area[0])->value;
			        {
				  OFstring_Dindexc(LVcc, ((string) &str9));
				  if (OMint_Dequal(retval_area[0], 0))
				    {
				      signame = SLBAD_FORMAT;
				      goto except3;
				    }
				  OFstring_Dappend(LVs, LVcc);
				  LVs = retval_area[0];
				  if (OFstream_Dgetc(LVst) == SIG)
				    {
				      goto except3;
				    }
			        }
			    }
			  else
			    {
			      signame = SLBAD_FORMAT;
			      goto except3;
			    }
			  if (FALSE)
			    {
			    except3:
			      if (OMstring_Dequal(signame, SLBOUNDS))
			        {
				  signame = SLBAD_FORMAT;
				  goto except2;
			        }
			      else
			        {
				  goto except2;
			        }
			    }
		        }
		    }
	        }
	      if (OFstring_Drest(LVs, 2) == SIG)
	        {
		  goto except2;
	        }
	      if (AFint__hex__parse(retval_area[0]) == SIG)
	        {
		  goto except2;
	        }
	      if (OMchar_Dillegal__char(retval_area[0]))
	        {
		  signame = SLILLEGAL_CHAR;
		  goto except2;
	        }
	      retval_area[0] = OMchar_Di2c(retval_area[0]);
	      return RET;
	    }
        }
    }
  else if (t1 == 3)
    {
      object LVc= 0;
      LVc = ((oneof) LVk)->value;
        {
	  object LVres= 0;
	  if (OMstring_Dbounds(LVs, 1))
	    {
	      signame = SLBOUNDS;
	      goto except2;
	    }
	  if (OMbool_Dnot(OMchar_Dequal(OMstring_Dfetch(LVs, 1), LVc)))
	    {
	      OFstring_Dc2s(LVc);
	      LVs = retval_area[0];
	    }
	    {
	      object LVi= 0;
	      for (t2 = 2; t2 <= 3; t2 += 1)
	        {
		  LVi = t2;
		    {
		      if (OFstream_Dpeekc(LVst) == SIG)
		        {
			  goto except2;
		        }
		      if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
		        {
			  goto except2;
		        }
		      t3 = ((oneof) retval_area[0])->tag;
		      if (t3 == 3)
		        {
			  object LVcc= 0;
			  LVcc = ((oneof) retval_area[0])->value;
			    {
			      OFstring_Dappend(LVs, LVcc);
			      LVs = retval_area[0];
			      if (OFstream_Dgetc(LVst) == SIG)
			        {
				  goto except2;
			        }
			    }
		        }
		      else
		        {
			  signame = SLBAD_FORMAT;
			  goto except2;
		        }
		    }
	        }
	    }
	  if (AFint__oct__parse(LVs) == SIG)
	    {
	      goto except2;
	    }
	  LVres = retval_area[0];
	  if (OMchar_Dillegal__char(LVres))
	    {
	      signame = SLILLEGAL_CHAR;
	      goto except2;
	    }
	  retval_area[0] = OMchar_Di2c(LVres);
	  return RET;
        }
    }
  else if (t1 == 6)
    {
      object LVf= 0;
      LVf = ((oneof) LVk)->value;
        {
	  t2 = ((oneof) LVf)->tag;
	  if (t2 == 2)
	    {
	        {
		  if (OMbool_Dnot(OMstring_Dequal(LVs, ((string) &str27))))
		    {
		      LVs = ((string) &str27);
		    }
		  if (OMbool_Dnot(OMrecord_Dget(8, LVe)))
		    {
		      if (OFp__env_Dbad(LVe, SLNULL, ((string) &str28)) == SIG)
		        {
			  goto except2;
		        }
		    }
		  if (OFstream_Dpeekc(LVst) == SIG)
		    {
		      goto except2;
		    }
		  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
		    {
		      goto except2;
		    }
		  LVk = retval_area[0];
		  t3 = ((oneof) LVk)->tag;
		  if (t3 == 4)
		    {
		        {
			  if (OFp__env_Dbad(LVe, SLNULL, ((string) &str29)) == SIG)
			    {
			      goto except2;
			    }
			  retval_area[0] = '?';
			  return RET;
		        }
		    }
		  else
		    {
		      if (OFstream_Dgetc(LVst) == SIG)
		        {
			  goto except2;
		        }
		      OFstring_Dappend(LVs, retval_area[0]);
		      LVs = retval_area[0];
		    }
		  t3 = ((oneof) LVk)->tag;
		  if (t3 == 8)
		    {
		      object LVc= 0;
		      LVc = ((oneof) LVk)->value;
		        {
			  if (OMchar_Dequal(LVc, '_'))
			    {
			      LVc = '\177';
			    }
			  t4 = OMint_Dsub(OMchar_Dc2i(LVc), 96);
			  if (OMchar_Dillegal__char(t4))
			    {
			      signame = SLILLEGAL_CHAR;
			      goto except2;
			    }
			  retval_area[0] = OMchar_Di2c(t4);
			  return RET;
		        }
		    }
		  else if (t3 == 4)
		    {
		        {
		        }
		    }
		  else if (t3 == 5)
		    {
		        {
			  retval_area[0] = '\034';
			  return RET;
		        }
		    }
		  else if (t3 == 12)
		    {
		      object LVt= 0;
		      LVt = ((oneof) LVk)->value;
		        {
			  t4 = ((oneof) LVt)->tag;
			  if (t4 == 20)
			    {
			        {
				  retval_area[0] = '\033';
				  return RET;
			        }
			    }
			  else if (t4 == 27)
			    {
			        {
				  retval_area[0] = '\035';
				  return RET;
			        }
			    }
		        }
		    }
		  else if (t3 == 6)
		    {
		      object LVff= 0;
		      LVff = ((oneof) LVk)->value;
		        {
			  t4 = ((oneof) LVff)->tag;
			  if (t4 == 1)
			    {
			        {
				  retval_area[0] = '\000';
				  return RET;
			        }
			    }
			  else if (t4 == 2)
			    {
			        {
				  retval_area[0] = '\036';
				  return RET;
			        }
			    }
			  else if (t4 == 4)
			    {
			        {
				  retval_area[0] = '\177';
				  return RET;
			        }
			    }
		        }
		    }
	        }
	    }
        }
    }
  if (FALSE)
    {
    except2:
      if (OMstring_Dequal(signame, SLBAD_FORMAT) || OMstring_Dequal(signame, SLILLEGAL_CHAR) || OMstring_Dequal(signame, SLBOUNDS) || OMstring_Dequal(signame, SLEND_OF_FILE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  t1 = OMstring_Dsize(((string) &str30))
       + OMstring_Dsize(LVs);
  t2 = OFstring_D__predict(t1);
  OFstring_D__concat(t2, ((string) &str30));
  OFstring_D__concat(t2, LVs);
  if (OFp__env_Dbad(LVe, t2, ((string) &str31)) == SIG)
    {
      goto except0;
    }
  retval_area[0] = '?';
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dmcharop */
/* clu_operation_name, p_env$mcharop */
int OFp__env_Dmcharop(LVe, LVmtok)
     object LVe;
     object LVmtok;
{
  object LVst= 0;
  object LVtok= 0;
  int t1, t2, t3, t4, t5, t6;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  t1 = ((oneof) LVmtok)->tag;
  if (t1 == 5)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 3)
	    {
	        {
		  object LVb= 0;
		  LVb = OMrecord_Dget(20, LVe);
		  if (OFarray_Dtrim(LVb, 1, 0) == SIG)
		    {
		      goto except1;
		    }
		  OMarray_Daddh(LVb, '.');
		  if (OFp__env_Dreallit(LVe, LVb) == SIG)
		    {
		      goto except1;
		    }
		  return RET;
	        }
	    }
        }
    }
  else if (t1 == 2)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 12)
	    {
	      object LVpt= 0;
	      LVpt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpt)->tag;
		  if (t3 == 11)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  OFoneof_Dmake(1, NIL);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 8)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 9)
	    {
	      object LVpmt= 0;
	      LVpmt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpmt)->tag;
		  if (t3 == 8)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, FALSE);
			  OMstruct_D__set(2, t4, ((string) &str32));
			  OMstruct_D__set(3, t4, 4);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 1)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 9)
	    {
	      object LVpmt= 0;
	      LVpmt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpmt)->tag;
		  if (t3 == 1)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, FALSE);
			  OMstruct_D__set(2, t4, ((string) &str33));
			  OMstruct_D__set(3, t4, 6);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 6)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 9)
	    {
	      object LVpmt= 0;
	      LVpmt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpmt)->tag;
		  if (t3 == 6)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, FALSE);
			  OMstruct_D__set(2, t4, ((string) &str34));
			  OMstruct_D__set(3, t4, 5);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 4)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 12)
	    {
	      object LVpt= 0;
	      LVpt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpt)->tag;
		  if (t3 == 11)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, FALSE);
			  OMstruct_D__set(2, t4, ((string) &str35));
			  OMstruct_D__set(3, t4, 3);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 3)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 12)
	    {
	      object LVpt= 0;
	      LVpt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpt)->tag;
		  if (t3 == 11)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, FALSE);
			  OMstruct_D__set(2, t4, ((string) &str36));
			  OMstruct_D__set(3, t4, 3);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
        }
    }
  else if (t1 == 7)
    {
      object LVt= 0;
      LVt = ((oneof) LVmtok)->value;
        {
	  LVtok = LVt;
	  if (OFstream_Dpeekc(LVst) == SIG)
	    {
	      goto except1;
	    }
	  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	    {
	      goto except1;
	    }
	  t2 = ((oneof) retval_area[0])->tag;
	  if (t2 == 12)
	    {
	      object LVpt= 0;
	      LVpt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpt)->tag;
		  if (t3 == 11)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, TRUE);
			  OMstruct_D__set(2, t4, ((string) &str37));
			  OMstruct_D__set(3, t4, 3);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
		        }
		    }
	        }
	    }
	  else if (t2 == 9)
	    {
	      object LVpmt= 0;
	      LVpmt = ((oneof) retval_area[0])->value;
	        {
		  t3 = ((oneof) LVpmt)->tag;
		  if (t3 == 4)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, TRUE);
			  OMstruct_D__set(2, t4, ((string) &str38));
			  OMstruct_D__set(3, t4, 3);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
			  if (OFstream_Dpeekc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
			    {
			      goto except1;
			    }
			  t4 = ((oneof) retval_area[0])->tag;
			  if (t4 == 12)
			    {
			      object LVppt= 0;
			      LVppt = ((oneof) retval_area[0])->value;
			        {
				  t5 = ((oneof) LVppt)->tag;
				  if (t5 == 11)
				    {
				        {
					  if (OFstream_Dgetc(LVst) == SIG)
					    {
					      goto except1;
					    }
					  t6 = OFstruct_D__alloc(3);
					  OMstruct_D__set(1, t6, TRUE);
					  OMstruct_D__set(2, t6, ((string) &str35));
					  OMstruct_D__set(3, t6, 3);
					  OFoneof_Dmake(24, t6);
					  LVtok = retval_area[0];
				        }
				    }
			        }
			    }
		        }
		    }
		  else if (t3 == 3)
		    {
		        {
			  if (OFstream_Dgetc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  t4 = OFstruct_D__alloc(3);
			  OMstruct_D__set(1, t4, TRUE);
			  OMstruct_D__set(2, t4, ((string) &str39));
			  OMstruct_D__set(3, t4, 3);
			  OFoneof_Dmake(24, t4);
			  LVtok = retval_area[0];
			  if (OFstream_Dpeekc(LVst) == SIG)
			    {
			      goto except1;
			    }
			  if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
			    {
			      goto except1;
			    }
			  t4 = ((oneof) retval_area[0])->tag;
			  if (t4 == 12)
			    {
			      object LVppt= 0;
			      LVppt = ((oneof) retval_area[0])->value;
			        {
				  t5 = ((oneof) LVppt)->tag;
				  if (t5 == 11)
				    {
				        {
					  if (OFstream_Dgetc(LVst) == SIG)
					    {
					      goto except1;
					    }
					  t6 = OFstruct_D__alloc(3);
					  OMstruct_D__set(1, t6, TRUE);
					  OMstruct_D__set(2, t6, ((string) &str36));
					  OMstruct_D__set(3, t6, 3);
					  OFoneof_Dmake(24, t6);
					  LVtok = retval_area[0];
				        }
				    }
			        }
			    }
		        }
		    }
	        }
	    }
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLEND_OF_FILE) || OMstring_Dequal(signame, SLBOUNDS))
        {
        }
      else
        {
	  goto except0;
        }
    }
  OMarray_Daddh(OMrecord_Dget(16, LVe), LVtok);
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dcomment */
/* clu_operation_name, p_env$comment */
int OFp__env_Dcomment(LVe)
     object LVe;
{
  object LVst= 0;
  int t1, t2, t3;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(10, LVe);
  while (TRUE)
    {
        {
	    {
	      if (OFstream_Dpeekc(LVst) == SIG)
	        {
		  goto except1;
	        }
	      if (OFjkindlist_Dfetch(WVchrvec_IN_Cp__env, OMchar_Dc2i(retval_area[0])) == SIG)
	        {
		  goto except1;
	        }
	      t1 = ((oneof) retval_area[0])->tag;
	      if (t1 == 7)
	        {
		    {
		      object LVc= 0;
		      if (OFstream_Dgetc(LVst) == SIG)
		        {
			  goto except1;
		        }
		      LVc = retval_area[0];
		      if (AFcprint__form(LVc) == SIG)
		        {
			  goto except1;
		        }
		      if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str40)) == SIG)
		        {
			  goto except1;
		        }
		    }
	        }
	      else if (t1 == 1)
	        {
		  object LVis__space= 0;
		  LVis__space = ((oneof) retval_area[0])->value;
		    {
		      object LVc= 0;
		      if (OFstream_Dgetc(LVst) == SIG)
		        {
			  goto except1;
		        }
		      LVc = retval_area[0];
		      t2 = FALSE;
		      if (OMchar_Dequal(LVc, '\f'))
		        {
			  if (OFstream_Dpeekc(LVst) == SIG)
			    {
			      goto except2;
			    }
			  if (OMchar_Dequal(retval_area[0], '\n'))
			    {
			      t2 = TRUE;
			    }
		        }
		      if (t2)
		        {
			  return RET;
		        }
		      else
		        {
			  if (LVis__space)
			    {
			      t3 = TRUE;
			    }
			  else
			    {
			      t3 = OMchar_Dequal(LVc, '\t');
			    }
			  if (OMbool_Dnot(t3))
			    {
			      if (AFcprint__form(LVc) == SIG)
			        {
				  goto except2;
			        }
			      if (OFp__env_Dbad(LVe, retval_area[0], ((string) &str40)) == SIG)
			        {
				  goto except2;
			        }
			    }
		        }
		      if (FALSE)
		        {
			except2:
			  if (OMstring_Dequal(signame, SLEND_OF_FILE))
			    {
			      return RET;
			    }
			  else
			    {
			      goto except1;
			    }
		        }
		    }
	        }
	      else if (t1 == 4)
	        {
		    {
		      return RET;
		    }
	        }
	      else
	        {
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except1;
		    }
	        }
	    }
	  if (FALSE)
	    {
	    except1:
	      if (OMstring_Dequal(signame, SLBOUNDS))
	        {
		  if (OFstream_Dgetc(LVst) == SIG)
		    {
		      goto except0;
		    }
	        }
	      else if (OMstring_Dequal(signame, SLEND_OF_FILE))
	        {
		  return RET;
	        }
	      else
	        {
		  goto except0;
	        }
	    }
        }
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFp__env_Dbad */
/* clu_operation_name, p_env$bad */
int OFp__env_Dbad(LVe, LVtext, LVwhy)
     object LVe;
     object LVtext;
     object LVwhy;
{
  object LVst= 0;
  if (IV_IN_Cp__env == FALSE)
    {
      IV_IN_Cp__env = TRUE;
      if (IF_IN_Cp__env() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  LVst = OMrecord_Dget(6, LVe);
    {
      OFint_Dunparse(OMrecord_Dget(9, LVe));
      if (OFstream_Dputs(LVst, retval_area[0]) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, ((string) &str3)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, OMrecord_Dget(7, LVe)) == SIG)
        {
	  goto except1;
        }
      if (OFstream_Dputs(LVst, LVwhy) == SIG)
        {
	  goto except1;
        }
      if (OMbool_Dnot(OMstring_Dempty(LVtext)))
        {
	  if (OFstream_Dputs(LVst, ((string) &str41)) == SIG)
	    {
	      goto except1;
	    }
	  if (OFstream_Dputs(LVst, LVtext) == SIG)
	    {
	      goto except1;
	    }
        }
      if (OFstream_Dputc(LVst, '\n') == SIG)
        {
	  goto except1;
        }
    }
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLNOT_POSSIBLE))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (OMint_Dgt(1, OMrecord_Dget(5, LVe)))
    {
      OMrecord_Dset(5, LVe, 1);
    }
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, IF_IN_Cp__env */
/* clu_operation_name, p_env$#initown */
int IF_IN_Cp__env()
{
  /* begin body */
  if (OFjkindlist_Dnew() == SIG)
    {
      goto except0;
    }
  WVchrvec_IN_Cp__env = retval_area[0];
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* end module */

/* begin module */
/* c_function_name, AFcprint__form */
/* clu_operation_name, cprint_form */
int AFcprint__form(LVc)
     object LVc;
{
  object LVi= 0;
  int t1, t2, t3;
  /* begin body */
  if (OMchar_Dlt(LVc, ' '))
    {
      t1 = OMint_Dadd(OMchar_Dc2i(LVc), 64);
      if (OMchar_Dillegal__char(t1))
        {
	  signame = SLILLEGAL_CHAR;
	  goto except0;
        }
      OFstring_Dappend(((string) &str27), OMchar_Di2c(t1));
      retval_area[0] = retval_area[0];
      return RET;
    }
  else
    {
      if (OMchar_Dlt(LVc, '\177'))
        {
	  OFstring_Dc2s(LVc);
	  retval_area[0] = retval_area[0];
	  return RET;
        }
      else
        {
	  if (OMchar_Dequal(LVc, '\177'))
	    {
	      retval_area[0] = ((string) &str42);
	      return RET;
	    }
        }
    }
  LVi = OMchar_Dc2i(LVc);
  if (OMint_Dlt(LVi, 160))
    {
      t1 = TRUE;
    }
  else
    {
      t1 = OMint_Dequal(LVi, 255);
    }
  if (t1)
    {
      t2 = OMint_Dsub(LVi, 64);
      if (OMint_Dzero__divide(128))
        {
	  signame = SLZERO_DIVIDE;
	  goto except0;
        }
      t3 = OMint_Dmod(t2, 128);
      if (OMchar_Dillegal__char(t3))
        {
	  signame = SLILLEGAL_CHAR;
	  goto except0;
        }
      OFstring_Dappend(((string) &str43), OMchar_Di2c(t3));
      retval_area[0] = retval_area[0];
      return RET;
    }
  else
    {
      if (OMint_Dlt(LVi, 255))
        {
	  t2 = OMint_Dsub(LVi, 128);
	  if (OMchar_Dillegal__char(t2))
	    {
	      signame = SLILLEGAL_CHAR;
	      goto except0;
	    }
	  OFstring_Dappend(((string) &str44), OMchar_Di2c(t2));
	  retval_area[0] = retval_area[0];
	  return RET;
        }
      else
        {
	  OFstring_Dc2s(LVc);
	  retval_area[0] = retval_area[0];
	  return RET;
        }
    }
  /* end body */
  noretval(SLNULL);
  return(SIG);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* end module */

/* begin module */
/* c_function_name, OFjkindlist_Dnew */
/* clu_operation_name, jkindlist$new */
int OFjkindlist_Dnew()
{
  object LVlist= 0;
  int t1, t2, t3, t4, t5;
  if (IV_IN_Cjkindlist == FALSE)
    {
      IV_IN_Cjkindlist = TRUE;
      if (IF_IN_Cjkindlist() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if ((*((proctype)PV1_INjkindlist_Dnew))(256, OFjkindlist_Dhash__int, OFint_Dequal) == SIG)
    {
      goto except0;
    }
  LVlist = retval_area[0];
    {
      object LVi= 0;
      t1 = OMchar_Dc2i(' ');
      for (t2 = t1, t3 = OMchar_Dc2i('~'); t2 <= t3; t2++)
        {
	  LVi = t2;
	    {
	      t4 = OMint_Dadd(OMint_Dsub(LVi, OMchar_Dc2i(' ')), 1);
	      if (OMsequence_Dbounds(WVucharlist_IN_Cjkindlist, t4))
	        {
		  signame = SLBOUNDS;
		  goto except0;
	        }
	      t5 = OMsequence_Dfetch(WVucharlist_IN_Cjkindlist, t4);
	      if (OMsequence_Dbounds(WVchrvec_IN_Cjkindlist, LVi))
	        {
		  signame = SLBOUNDS;
		  goto except0;
	        }
	      if ((*((proctype)PV2_INjkindlist_Dnew))(LVlist, t5, OMsequence_Dfetch(WVchrvec_IN_Cjkindlist, LVi)) == SIG)
	        {
		  goto except0;
	        }
	    }
        }
    }
    {
      object LVi= 0;
      for (t1 = 8481; t1 <= 8830; t1++)
        {
	  LVi = t1;
	    {
	      OFoneof_Dmake(3, NIL);
	      OFoneof_Dmake(6, retval_area[0]);
	      if ((*((proctype)PV3_INjkindlist_Dnew))(LVlist, LVi, retval_area[0]) == SIG)
	        {
		  goto except0;
	        }
	    }
        }
    }
    {
      object LVi= 0;
      for (t1 = WVscharlist_IN_Cjkindlist, t2 = 1, t3 = OMsequence_Dsize(t1);
           t2 <= t3;
           t2++)
        {
	  LVi = OMsequence_Dfetch(t1, t2);
	    {
	      if ((*((proctype)PV4_INjkindlist_Dnew))(LVlist, LVi) == SIG)
	        {
		  goto except0;
	        }
	    }
        }
    }
    {
      object LVi= 0;
      for (t1 = 10273; t1 <= 10304; t1++)
        {
	  LVi = t1;
	    {
	      OFoneof_Dmake(3, NIL);
	      OFoneof_Dmake(6, retval_area[0]);
	      if ((*((proctype)PV5_INjkindlist_Dnew))(LVlist, LVi, retval_area[0]) == SIG)
	        {
		  goto except0;
	        }
	    }
        }
    }
  retval_area[0] = LVlist;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFjkindlist_Dfetch */
/* clu_operation_name, jkindlist$fetch */
int OFjkindlist_Dfetch(LVlist, LVi)
     object LVlist;
     object LVi;
{
  object LVkind= 0;
  if (IV_IN_Cjkindlist == FALSE)
    {
      IV_IN_Cjkindlist = TRUE;
      if (IF_IN_Cjkindlist() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMsequence_Dbounds(WVchrvec_IN_Cjkindlist, LVi))
    {
      signame = SLBOUNDS;
      goto except1;
    }
  retval_area[0] = OMsequence_Dfetch(WVchrvec_IN_Cjkindlist, LVi);
  return RET;
  if (FALSE)
    {
    except1:
      if (OMstring_Dequal(signame, SLBOUNDS))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if ((*((proctype)PV1_INjkindlist_Dfetch))(LVlist, LVi) == SIG)
    {
      goto except2;
    }
  retval_area[0] = retval_area[0];
  return RET;
  if (FALSE)
    {
    except2:
      if (OMstring_Dequal(signame, SLNOT_FOUND))
        {
        }
      else
        {
	  goto except0;
        }
    }
  if (OMchar_Dillegal__char(LVi))
    {
      signame = SLILLEGAL_CHAR;
      goto except0;
    }
  OFoneof_Dmake(8, OMchar_Di2c(LVi));
  LVkind = retval_area[0];
  if ((*((proctype)PV2_INjkindlist_Dfetch))(LVlist, LVi, LVkind) == SIG)
    {
      goto except0;
    }
  retval_area[0] = LVkind;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, OFjkindlist_Dhash__int */
/* clu_operation_name, jkindlist$hash_int */
int OFjkindlist_Dhash__int(LVkey, LVsize)
     object LVkey;
     object LVsize;
{
  if (IV_IN_Cjkindlist == FALSE)
    {
      IV_IN_Cjkindlist = TRUE;
      if (IF_IN_Cjkindlist() == SIG)
        {
	  goto except0;
        }
    }
  /* begin body */
  if (OMint_Dzero__divide(LVsize))
    {
      signame = SLZERO_DIVIDE;
      goto except0;
    }
  retval_area[0] = OMint_Dmod(LVkey, LVsize);
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* c_function_name, IF_IN_Cjkindlist */
/* clu_operation_name, jkindlist$#initown */
int IF_IN_Cjkindlist()
{
  int t1;
  /* begin body */
  if (AFinit__klist() == SIG)
    {
      goto except0;
    }
  WVchrvec_IN_Cjkindlist = retval_area[0];
  t1 = OFsequence_D__alloc(95);
  OMsequence_D__store(t1, 1, 8481);
  OMsequence_D__store(t1, 2, 8490);
  OMsequence_D__store(t1, 3, 8521);
  OMsequence_D__store(t1, 4, 8564);
  OMsequence_D__store(t1, 5, 8560);
  OMsequence_D__store(t1, 6, 8563);
  OMsequence_D__store(t1, 7, 8565);
  OMsequence_D__store(t1, 8, 8519);
  OMsequence_D__store(t1, 9, 8522);
  OMsequence_D__store(t1, 10, 8523);
  OMsequence_D__store(t1, 11, 8566);
  OMsequence_D__store(t1, 12, 8540);
  OMsequence_D__store(t1, 13, 8484);
  OMsequence_D__store(t1, 14, 8541);
  OMsequence_D__store(t1, 15, 8485);
  OMsequence_D__store(t1, 16, 8511);
  OMsequence_D__store(t1, 17, 9008);
  OMsequence_D__store(t1, 18, 9009);
  OMsequence_D__store(t1, 19, 9010);
  OMsequence_D__store(t1, 20, 9011);
  OMsequence_D__store(t1, 21, 9012);
  OMsequence_D__store(t1, 22, 9013);
  OMsequence_D__store(t1, 23, 9014);
  OMsequence_D__store(t1, 24, 9015);
  OMsequence_D__store(t1, 25, 9016);
  OMsequence_D__store(t1, 26, 9017);
  OMsequence_D__store(t1, 27, 8487);
  OMsequence_D__store(t1, 28, 8488);
  OMsequence_D__store(t1, 29, 8547);
  OMsequence_D__store(t1, 30, 8545);
  OMsequence_D__store(t1, 31, 8548);
  OMsequence_D__store(t1, 32, 8489);
  OMsequence_D__store(t1, 33, 8567);
  OMsequence_D__store(t1, 34, 9025);
  OMsequence_D__store(t1, 35, 9026);
  OMsequence_D__store(t1, 36, 9027);
  OMsequence_D__store(t1, 37, 9028);
  OMsequence_D__store(t1, 38, 9029);
  OMsequence_D__store(t1, 39, 9030);
  OMsequence_D__store(t1, 40, 9031);
  OMsequence_D__store(t1, 41, 9032);
  OMsequence_D__store(t1, 42, 9033);
  OMsequence_D__store(t1, 43, 9034);
  OMsequence_D__store(t1, 44, 9035);
  OMsequence_D__store(t1, 45, 9036);
  OMsequence_D__store(t1, 46, 9037);
  OMsequence_D__store(t1, 47, 9038);
  OMsequence_D__store(t1, 48, 9039);
  OMsequence_D__store(t1, 49, 9040);
  OMsequence_D__store(t1, 50, 9041);
  OMsequence_D__store(t1, 51, 9042);
  OMsequence_D__store(t1, 52, 9043);
  OMsequence_D__store(t1, 53, 9044);
  OMsequence_D__store(t1, 54, 9045);
  OMsequence_D__store(t1, 55, 9046);
  OMsequence_D__store(t1, 56, 9047);
  OMsequence_D__store(t1, 57, 9048);
  OMsequence_D__store(t1, 58, 9049);
  OMsequence_D__store(t1, 59, 9050);
  OMsequence_D__store(t1, 60, 8526);
  OMsequence_D__store(t1, 61, 8559);
  OMsequence_D__store(t1, 62, 8527);
  OMsequence_D__store(t1, 63, 8496);
  OMsequence_D__store(t1, 64, 8498);
  OMsequence_D__store(t1, 65, 8518);
  OMsequence_D__store(t1, 66, 9057);
  OMsequence_D__store(t1, 67, 9058);
  OMsequence_D__store(t1, 68, 9059);
  OMsequence_D__store(t1, 69, 9060);
  OMsequence_D__store(t1, 70, 9061);
  OMsequence_D__store(t1, 71, 9062);
  OMsequence_D__store(t1, 72, 9063);
  OMsequence_D__store(t1, 73, 9064);
  OMsequence_D__store(t1, 74, 9065);
  OMsequence_D__store(t1, 75, 9066);
  OMsequence_D__store(t1, 76, 9067);
  OMsequence_D__store(t1, 77, 9068);
  OMsequence_D__store(t1, 78, 9069);
  OMsequence_D__store(t1, 79, 9070);
  OMsequence_D__store(t1, 80, 9071);
  OMsequence_D__store(t1, 81, 9072);
  OMsequence_D__store(t1, 82, 9073);
  OMsequence_D__store(t1, 83, 9074);
  OMsequence_D__store(t1, 84, 9075);
  OMsequence_D__store(t1, 85, 9076);
  OMsequence_D__store(t1, 86, 9077);
  OMsequence_D__store(t1, 87, 9078);
  OMsequence_D__store(t1, 88, 9079);
  OMsequence_D__store(t1, 89, 9080);
  OMsequence_D__store(t1, 90, 9081);
  OMsequence_D__store(t1, 91, 9082);
  OMsequence_D__store(t1, 92, 8528);
  OMsequence_D__store(t1, 93, 8515);
  OMsequence_D__store(t1, 94, 8529);
  OMsequence_D__store(t1, 95, 8497);
  WVucharlist_IN_Cjkindlist = t1;
  t1 = OFsequence_D__alloc(8);
  OMsequence_D__store(t1, 1, 8491);
  OMsequence_D__store(t1, 2, 8492);
  OMsequence_D__store(t1, 3, 8499);
  OMsequence_D__store(t1, 4, 8500);
  OMsequence_D__store(t1, 5, 8501);
  OMsequence_D__store(t1, 6, 8502);
  OMsequence_D__store(t1, 7, 8505);
  OMsequence_D__store(t1, 8, 8508);
  WVscharlist_IN_Cjkindlist = t1;
  /* end body */
  return(RET);
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* end module */

/* begin module */
/* c_function_name, AFinit__klist */
/* clu_operation_name, init_klist */
int AFinit__klist()
{
  int t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
  int t11, t12, t13, t14, t15, t16, t17, t18, t19, t20;
  int t21, t22, t23, t24, t25, t26, t27, t28, t29, t30;
  int t31, t32, t33, t34, t35, t36, t37, t38, t39, t40;
  int t41, t42, t43, t44, t45, t46, t47, t48, t49, t50;
  int t51, t52, t53, t54, t55, t56, t57, t58, t59, t60;
  int t61, t62, t63, t64, t65, t66, t67, t68, t69, t70;
  int t71, t72, t73, t74, t75, t76, t77, t78, t79, t80;
  int t81, t82, t83, t84, t85, t86, t87, t88, t89, t90;
  int t91, t92, t93, t94, t95, t96, t97, t98, t99, t100;
  int t101, t102, t103, t104, t105, t106, t107, t108, t109, t110;
  int t111, t112, t113, t114, t115, t116, t117, t118, t119, t120;
  int t121, t122, t123, t124, t125, t126, t127, t128, t129, t130;
  int t131, t132, t133, t134, t135, t136;
  /* begin body */
  OFoneof_Dmake(7, NIL);
  t1 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t2 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t3 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t4 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t5 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t6 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t7 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t8 = retval_area[0];
  OFoneof_Dmake(1, FALSE);
  t9 = retval_area[0];
  OFoneof_Dmake(4, NIL);
  t10 = retval_area[0];
  OFoneof_Dmake(1, FALSE);
  t11 = retval_area[0];
  OFoneof_Dmake(1, FALSE);
  t12 = retval_area[0];
  OFoneof_Dmake(1, FALSE);
  t13 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t14 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t15 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t16 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t17 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t18 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t19 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t20 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t21 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t22 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t23 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t24 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t25 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t26 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t27 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t28 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t29 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t30 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t31 = retval_area[0];
  OFoneof_Dmake(1, TRUE);
  t32 = retval_area[0];
  OFoneof_Dmake(13, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t33 = retval_area[0];
  OFoneof_Dmake(11, NIL);
  t34 = retval_area[0];
  OFoneof_Dmake(33, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t35 = retval_area[0];
  OFoneof_Dmake(6, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t36 = retval_area[0];
  OFoneof_Dmake(2, NIL);
  t37 = retval_area[0];
  t38 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t38, FALSE);
  OMstruct_D__set(2, t38, ((string) &str45));
  OMstruct_D__set(3, t38, 2);
  OFoneof_Dmake(24, t38);
  OFoneof_Dmake(12, retval_area[0]);
  t39 = retval_area[0];
  OFoneof_Dmake(10, NIL);
  t40 = retval_area[0];
  OFoneof_Dmake(22, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t41 = retval_area[0];
  OFoneof_Dmake(29, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t42 = retval_area[0];
  t43 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t43, FALSE);
  OMstruct_D__set(2, t43, ((string) &str46));
  OMstruct_D__set(3, t43, 5);
  OFoneof_Dmake(24, t43);
  OFoneof_Dmake(1, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t44 = retval_area[0];
  t45 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t45, FALSE);
  OMstruct_D__set(2, t45, ((string) &str13));
  OMstruct_D__set(3, t45, 4);
  OFoneof_Dmake(24, t45);
  OFoneof_Dmake(12, retval_area[0]);
  t46 = retval_area[0];
  OFoneof_Dmake(3, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t47 = retval_area[0];
  t48 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t48, FALSE);
  OMstruct_D__set(2, t48, ((string) &str14));
  OMstruct_D__set(3, t48, 4);
  OFoneof_Dmake(24, t48);
  OFoneof_Dmake(12, retval_area[0]);
  t49 = retval_area[0];
  OFoneof_Dmake(26, NIL);
  OFoneof_Dmake(5, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t50 = retval_area[0];
  t51 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t51, FALSE);
  OMstruct_D__set(2, t51, ((string) &str47));
  OMstruct_D__set(3, t51, 5);
  OFoneof_Dmake(24, t51);
  OFoneof_Dmake(6, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t52 = retval_area[0];
  OFoneof_Dmake(3, '0');
  t53 = retval_area[0];
  OFoneof_Dmake(3, '1');
  t54 = retval_area[0];
  OFoneof_Dmake(3, '2');
  t55 = retval_area[0];
  OFoneof_Dmake(3, '3');
  t56 = retval_area[0];
  OFoneof_Dmake(3, '4');
  t57 = retval_area[0];
  OFoneof_Dmake(3, '5');
  t58 = retval_area[0];
  OFoneof_Dmake(3, '6');
  t59 = retval_area[0];
  OFoneof_Dmake(3, '7');
  t60 = retval_area[0];
  OFoneof_Dmake(3, '8');
  t61 = retval_area[0];
  OFoneof_Dmake(3, '9');
  t62 = retval_area[0];
  OFoneof_Dmake(2, NIL);
  OFoneof_Dmake(2, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t63 = retval_area[0];
  OFoneof_Dmake(32, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t64 = retval_area[0];
  t65 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t65, FALSE);
  OMstruct_D__set(2, t65, ((string) &str38));
  OMstruct_D__set(3, t65, 3);
  OFoneof_Dmake(24, t65);
  OFoneof_Dmake(4, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t66 = retval_area[0];
  t67 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t67, FALSE);
  OMstruct_D__set(2, t67, ((string) &str37));
  OMstruct_D__set(3, t67, 3);
  OFoneof_Dmake(11, t67);
  OFoneof_Dmake(12, retval_area[0]);
  t68 = retval_area[0];
  t69 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t69, FALSE);
  OMstruct_D__set(2, t69, ((string) &str39));
  OMstruct_D__set(3, t69, 3);
  OFoneof_Dmake(24, t69);
  OFoneof_Dmake(3, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t70 = retval_area[0];
  OFoneof_Dmake(4, NIL);
  OFoneof_Dmake(6, retval_area[0]);
  t71 = retval_area[0];
  OFoneof_Dmake(1, NIL);
  OFoneof_Dmake(6, retval_area[0]);
  t72 = retval_area[0];
  OFoneof_Dmake(8, 'a');
  t73 = retval_area[0];
  OFoneof_Dmake(8, 'b');
  t74 = retval_area[0];
  OFoneof_Dmake(8, 'c');
  t75 = retval_area[0];
  OFoneof_Dmake(8, 'd');
  t76 = retval_area[0];
  OFoneof_Dmake(8, 'e');
  t77 = retval_area[0];
  OFoneof_Dmake(8, 'f');
  t78 = retval_area[0];
  OFoneof_Dmake(8, 'g');
  t79 = retval_area[0];
  OFoneof_Dmake(8, 'h');
  t80 = retval_area[0];
  OFoneof_Dmake(8, 'i');
  t81 = retval_area[0];
  OFoneof_Dmake(8, 'j');
  t82 = retval_area[0];
  OFoneof_Dmake(8, 'k');
  t83 = retval_area[0];
  OFoneof_Dmake(8, 'l');
  t84 = retval_area[0];
  OFoneof_Dmake(8, 'm');
  t85 = retval_area[0];
  OFoneof_Dmake(8, 'n');
  t86 = retval_area[0];
  OFoneof_Dmake(8, 'o');
  t87 = retval_area[0];
  OFoneof_Dmake(8, 'p');
  t88 = retval_area[0];
  OFoneof_Dmake(8, 'q');
  t89 = retval_area[0];
  OFoneof_Dmake(8, 'r');
  t90 = retval_area[0];
  OFoneof_Dmake(8, 's');
  t91 = retval_area[0];
  OFoneof_Dmake(8, 't');
  t92 = retval_area[0];
  OFoneof_Dmake(8, 'u');
  t93 = retval_area[0];
  OFoneof_Dmake(8, 'v');
  t94 = retval_area[0];
  OFoneof_Dmake(8, 'w');
  t95 = retval_area[0];
  OFoneof_Dmake(8, 'x');
  t96 = retval_area[0];
  OFoneof_Dmake(8, 'y');
  t97 = retval_area[0];
  OFoneof_Dmake(8, 'z');
  t98 = retval_area[0];
  OFoneof_Dmake(20, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t99 = retval_area[0];
  OFoneof_Dmake(5, NIL);
  t100 = retval_area[0];
  OFoneof_Dmake(27, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t101 = retval_area[0];
  OFoneof_Dmake(2, NIL);
  OFoneof_Dmake(6, retval_area[0]);
  t102 = retval_area[0];
  OFoneof_Dmake(8, '_');
  t103 = retval_area[0];
  OFoneof_Dmake(3, NIL);
  OFoneof_Dmake(6, retval_area[0]);
  t104 = retval_area[0];
  OFoneof_Dmake(8, 'a');
  t105 = retval_area[0];
  OFoneof_Dmake(8, 'b');
  t106 = retval_area[0];
  OFoneof_Dmake(8, 'c');
  t107 = retval_area[0];
  OFoneof_Dmake(8, 'd');
  t108 = retval_area[0];
  OFoneof_Dmake(8, 'e');
  t109 = retval_area[0];
  OFoneof_Dmake(8, 'f');
  t110 = retval_area[0];
  OFoneof_Dmake(8, 'g');
  t111 = retval_area[0];
  OFoneof_Dmake(8, 'h');
  t112 = retval_area[0];
  OFoneof_Dmake(8, 'i');
  t113 = retval_area[0];
  OFoneof_Dmake(8, 'j');
  t114 = retval_area[0];
  OFoneof_Dmake(8, 'k');
  t115 = retval_area[0];
  OFoneof_Dmake(8, 'l');
  t116 = retval_area[0];
  OFoneof_Dmake(8, 'm');
  t117 = retval_area[0];
  OFoneof_Dmake(8, 'n');
  t118 = retval_area[0];
  OFoneof_Dmake(8, 'o');
  t119 = retval_area[0];
  OFoneof_Dmake(8, 'p');
  t120 = retval_area[0];
  OFoneof_Dmake(8, 'q');
  t121 = retval_area[0];
  OFoneof_Dmake(8, 'r');
  t122 = retval_area[0];
  OFoneof_Dmake(8, 's');
  t123 = retval_area[0];
  OFoneof_Dmake(8, 't');
  t124 = retval_area[0];
  OFoneof_Dmake(8, 'u');
  t125 = retval_area[0];
  OFoneof_Dmake(8, 'v');
  t126 = retval_area[0];
  OFoneof_Dmake(8, 'w');
  t127 = retval_area[0];
  OFoneof_Dmake(8, 'x');
  t128 = retval_area[0];
  OFoneof_Dmake(8, 'y');
  t129 = retval_area[0];
  OFoneof_Dmake(8, 'z');
  t130 = retval_area[0];
  OFoneof_Dmake(21, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t131 = retval_area[0];
  t132 = OFstruct_D__alloc(3);
  OMstruct_D__set(1, t132, FALSE);
  OMstruct_D__set(2, t132, ((string) &str48));
  OMstruct_D__set(3, t132, 1);
  OFoneof_Dmake(24, t132);
  OFoneof_Dmake(8, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t133 = retval_area[0];
  OFoneof_Dmake(28, NIL);
  OFoneof_Dmake(12, retval_area[0]);
  t134 = retval_area[0];
  OFoneof_Dmake(23, NIL);
  OFoneof_Dmake(7, retval_area[0]);
  OFoneof_Dmake(9, retval_area[0]);
  t135 = retval_area[0];
  OFoneof_Dmake(7, NIL);
  t136 = OFsequence_D__alloc(127);
  OMsequence_D__store(t136, 1, t1);
  OMsequence_D__store(t136, 2, t2);
  OMsequence_D__store(t136, 3, t3);
  OMsequence_D__store(t136, 4, t4);
  OMsequence_D__store(t136, 5, t5);
  OMsequence_D__store(t136, 6, t6);
  OMsequence_D__store(t136, 7, t7);
  OMsequence_D__store(t136, 8, t8);
  OMsequence_D__store(t136, 9, t9);
  OMsequence_D__store(t136, 10, t10);
  OMsequence_D__store(t136, 11, t11);
  OMsequence_D__store(t136, 12, t12);
  OMsequence_D__store(t136, 13, t13);
  OMsequence_D__store(t136, 14, t14);
  OMsequence_D__store(t136, 15, t15);
  OMsequence_D__store(t136, 16, t16);
  OMsequence_D__store(t136, 17, t17);
  OMsequence_D__store(t136, 18, t18);
  OMsequence_D__store(t136, 19, t19);
  OMsequence_D__store(t136, 20, t20);
  OMsequence_D__store(t136, 21, t21);
  OMsequence_D__store(t136, 22, t22);
  OMsequence_D__store(t136, 23, t23);
  OMsequence_D__store(t136, 24, t24);
  OMsequence_D__store(t136, 25, t25);
  OMsequence_D__store(t136, 26, t26);
  OMsequence_D__store(t136, 27, t27);
  OMsequence_D__store(t136, 28, t28);
  OMsequence_D__store(t136, 29, t29);
  OMsequence_D__store(t136, 30, t30);
  OMsequence_D__store(t136, 31, t31);
  OMsequence_D__store(t136, 32, t32);
  OMsequence_D__store(t136, 33, t33);
  OMsequence_D__store(t136, 34, t34);
  OMsequence_D__store(t136, 35, t35);
  OMsequence_D__store(t136, 36, t36);
  OMsequence_D__store(t136, 37, t37);
  OMsequence_D__store(t136, 38, t39);
  OMsequence_D__store(t136, 39, t40);
  OMsequence_D__store(t136, 40, t41);
  OMsequence_D__store(t136, 41, t42);
  OMsequence_D__store(t136, 42, t44);
  OMsequence_D__store(t136, 43, t46);
  OMsequence_D__store(t136, 44, t47);
  OMsequence_D__store(t136, 45, t49);
  OMsequence_D__store(t136, 46, t50);
  OMsequence_D__store(t136, 47, t52);
  OMsequence_D__store(t136, 48, t53);
  OMsequence_D__store(t136, 49, t54);
  OMsequence_D__store(t136, 50, t55);
  OMsequence_D__store(t136, 51, t56);
  OMsequence_D__store(t136, 52, t57);
  OMsequence_D__store(t136, 53, t58);
  OMsequence_D__store(t136, 54, t59);
  OMsequence_D__store(t136, 55, t60);
  OMsequence_D__store(t136, 56, t61);
  OMsequence_D__store(t136, 57, t62);
  OMsequence_D__store(t136, 58, t63);
  OMsequence_D__store(t136, 59, t64);
  OMsequence_D__store(t136, 60, t66);
  OMsequence_D__store(t136, 61, t68);
  OMsequence_D__store(t136, 62, t70);
  OMsequence_D__store(t136, 63, t71);
  OMsequence_D__store(t136, 64, t72);
  OMsequence_D__store(t136, 65, t73);
  OMsequence_D__store(t136, 66, t74);
  OMsequence_D__store(t136, 67, t75);
  OMsequence_D__store(t136, 68, t76);
  OMsequence_D__store(t136, 69, t77);
  OMsequence_D__store(t136, 70, t78);
  OMsequence_D__store(t136, 71, t79);
  OMsequence_D__store(t136, 72, t80);
  OMsequence_D__store(t136, 73, t81);
  OMsequence_D__store(t136, 74, t82);
  OMsequence_D__store(t136, 75, t83);
  OMsequence_D__store(t136, 76, t84);
  OMsequence_D__store(t136, 77, t85);
  OMsequence_D__store(t136, 78, t86);
  OMsequence_D__store(t136, 79, t87);
  OMsequence_D__store(t136, 80, t88);
  OMsequence_D__store(t136, 81, t89);
  OMsequence_D__store(t136, 82, t90);
  OMsequence_D__store(t136, 83, t91);
  OMsequence_D__store(t136, 84, t92);
  OMsequence_D__store(t136, 85, t93);
  OMsequence_D__store(t136, 86, t94);
  OMsequence_D__store(t136, 87, t95);
  OMsequence_D__store(t136, 88, t96);
  OMsequence_D__store(t136, 89, t97);
  OMsequence_D__store(t136, 90, t98);
  OMsequence_D__store(t136, 91, t99);
  OMsequence_D__store(t136, 92, t100);
  OMsequence_D__store(t136, 93, t101);
  OMsequence_D__store(t136, 94, t102);
  OMsequence_D__store(t136, 95, t103);
  OMsequence_D__store(t136, 96, t104);
  OMsequence_D__store(t136, 97, t105);
  OMsequence_D__store(t136, 98, t106);
  OMsequence_D__store(t136, 99, t107);
  OMsequence_D__store(t136, 100, t108);
  OMsequence_D__store(t136, 101, t109);
  OMsequence_D__store(t136, 102, t110);
  OMsequence_D__store(t136, 103, t111);
  OMsequence_D__store(t136, 104, t112);
  OMsequence_D__store(t136, 105, t113);
  OMsequence_D__store(t136, 106, t114);
  OMsequence_D__store(t136, 107, t115);
  OMsequence_D__store(t136, 108, t116);
  OMsequence_D__store(t136, 109, t117);
  OMsequence_D__store(t136, 110, t118);
  OMsequence_D__store(t136, 111, t119);
  OMsequence_D__store(t136, 112, t120);
  OMsequence_D__store(t136, 113, t121);
  OMsequence_D__store(t136, 114, t122);
  OMsequence_D__store(t136, 115, t123);
  OMsequence_D__store(t136, 116, t124);
  OMsequence_D__store(t136, 117, t125);
  OMsequence_D__store(t136, 118, t126);
  OMsequence_D__store(t136, 119, t127);
  OMsequence_D__store(t136, 120, t128);
  OMsequence_D__store(t136, 121, t129);
  OMsequence_D__store(t136, 122, t130);
  OMsequence_D__store(t136, 123, t131);
  OMsequence_D__store(t136, 124, t133);
  OMsequence_D__store(t136, 125, t134);
  OMsequence_D__store(t136, 126, t135);
  OMsequence_D__store(t136, 127, retval_area[0]);
  retval_area[0] = t136;
  return RET;
  /* end body */
except0:
  out_handler(SLNULL);
  return(SIG);
}
/* end module */
